<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>bwave::WaveletDecomp&lt; tp_rank &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>bwave</b>::<a class="el" href="classbwave_1_1WaveletDecomp.html">WaveletDecomp</a>
  </div>
</div>
<div class="contents">
<h1>bwave::WaveletDecomp&lt; tp_rank &gt; Class Template Reference</h1><!-- doxytag: class="bwave::WaveletDecomp" -->Represents a specific wavelet decomposition.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="WaveletDecomp_8h-source.html">WaveletDecomp.h</a>&gt;</code>
<p>

<p>
<a href="classbwave_1_1WaveletDecomp-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a768fa6f58cf4b26880429693c9d03ff"></a><!-- doxytag: member="bwave::WaveletDecomp::wavelet" ref="a768fa6f58cf4b26880429693c9d03ff" args="() const " -->
<a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a768fa6f58cf4b26880429693c9d03ff">wavelet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the wavelet used in this decomposition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="19f0705bd099bed3b797089529dd43e2"></a><!-- doxytag: member="bwave::WaveletDecomp::decompType" ref="19f0705bd099bed3b797089529dd43e2" args="() const " -->
DecompType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#19f0705bd099bed3b797089529dd43e2">decompType</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the type of this decomposition (i.e. standard or non-standard). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">CoeffStorage&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#0d51787edf5dc539915cdc08736deff6">storageMode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mode in which the wavelet/scaling coefficients are stored.  <a href="#0d51787edf5dc539915cdc08736deff6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">CoeffStorage&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#141d7f32187ccf3505b11a93ca14754e">storageMode</a> (CoeffStorage newCS)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode in which the wavelet/scaling coefficients are stored.  <a href="#141d7f32187ccf3505b11a93ca14754e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ExtensionMode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#e26d5ab9b356f70380374b3d73f416e8">extensionMode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current method used for boundary handling / array extension.  <a href="#e26d5ab9b356f70380374b3d73f416e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ExtensionMode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#219c8086b941f0586656e0d3b4a13b86">extensionMode</a> (ExtensionMode newEM)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the method to be used for boundary handling / array extension.  <a href="#219c8086b941f0586656e0d3b4a13b86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="498f6c2d9239b44033a9e71da5993c92"></a><!-- doxytag: member="bwave::WaveletDecomp::dimSelected" ref="498f6c2d9239b44033a9e71da5993c92" args="(int dim) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#498f6c2d9239b44033a9e71da5993c92">dimSelected</a> (int dim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if decomposition will be applied in array dimension <code>dim</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">blitz::TinyVector&lt; bool, tp_rank &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#3b743a86f4d63c9301c149f44b525bae">dimSelection</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimensions selected for decomposition.  <a href="#3b743a86f4d63c9301c149f44b525bae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">blitz::TinyVector&lt; bool, tp_rank &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#2fcbaf31109a9a7b6a0e4fad1d23d4c6">dimSelection</a> (blitz::TinyVector&lt; bool, tp_rank &gt; selection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select the dimensions in which to apply the wavelet decomposition.  <a href="#2fcbaf31109a9a7b6a0e4fad1d23d4c6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class tp_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#52608264814d0ba412b50cdb14f75e94">apply</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply this wavelet decomposition to a data array.  <a href="#52608264814d0ba412b50cdb14f75e94"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class tp_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#8ef8ef95820b358e873c8137e71a804c">applyInv</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply the inverse wavelet transformation.  <a href="#8ef8ef95820b358e873c8137e71a804c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class tp_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">blitz::Array<br>
&lt; blitz::TinyVector&lt; int, <br>
tp_rank &gt;, 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#419398fd640de191dbca7875cc7556fe">indices</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the indices of the coefficients that this decomposition will/has produce(d) for the given data.  <a href="#419398fd640de191dbca7875cc7556fe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class tp_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">blitz::Array&lt; tp_Type, tp_rank &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#2414383f06dfd9027ddc3fb5ded8a494">coeffs</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, blitz::TinyVector&lt; int, tp_rank &gt; indices) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all wavelet/scaling coefficients of the same type (i.e. corresponding to basis functions differing only by translation).  <a href="#2414383f06dfd9027ddc3fb5ded8a494"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#2650a3646c51ed0b3ae2f4601de6481a">normFactor</a> (blitz::TinyVector&lt; int, tp_rank &gt; indices) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the normalization factor for the specified coefficient type.  <a href="#2650a3646c51ed0b3ae2f4601de6481a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#add0a73ee7ba2f8d5ef1f77cb48442cb">WaveletDecomp</a> (<a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a> wl, DecompType decomp=NONSTD_DECOMP, int maxlevel=0, CoeffStorage cs=NESTED_COEFFS, ExtensionMode em=CONSTANT_EXT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new wavelet decomposition.  <a href="#add0a73ee7ba2f8d5ef1f77cb48442cb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="71eaa74d21261b2c8a90c02086c42261"></a><!-- doxytag: member="bwave::WaveletDecomp::trafoStep" ref="71eaa74d21261b2c8a90c02086c42261" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int targetDim, bool inverse) const " -->
template&lt;class tp_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>trafoStep</b> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int targetDim, bool inverse) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bb8a6eb2793e7c2f45388301352c5d71"></a><!-- doxytag: member="bwave::WaveletDecomp::waveletDecompose" ref="bb8a6eb2793e7c2f45388301352c5d71" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const " -->
template&lt;class tp_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>waveletDecompose</b> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6df8415cee521b5d8bd2e20f470c0188"></a><!-- doxytag: member="bwave::WaveletDecomp::waveletRecompose" ref="6df8415cee521b5d8bd2e20f470c0188" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const " -->
template&lt;class tp_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>waveletRecompose</b> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const </td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bd0e8af7873cb624c229c3c837e19467"></a><!-- doxytag: member="bwave::WaveletDecomp::m_wavelet" ref="bd0e8af7873cb624c229c3c837e19467" args="" -->
<a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_wavelet</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ed3c7720e6361de3c35603a4c29017c"></a><!-- doxytag: member="bwave::WaveletDecomp::m_decomp" ref="9ed3c7720e6361de3c35603a4c29017c" args="" -->
DecompType&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_decomp</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="215c93c60a7af9e377ea4f5afe82e254"></a><!-- doxytag: member="bwave::WaveletDecomp::m_storageMode" ref="215c93c60a7af9e377ea4f5afe82e254" args="" -->
CoeffStorage&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_storageMode</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60659292de9373c3dd7ef000af77b8ac"></a><!-- doxytag: member="bwave::WaveletDecomp::m_extMode" ref="60659292de9373c3dd7ef000af77b8ac" args="" -->
ExtensionMode&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_extMode</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="082f8150f0e4ca9cfa8aac0f14ba13be"></a><!-- doxytag: member="bwave::WaveletDecomp::m_maxLevel" ref="082f8150f0e4ca9cfa8aac0f14ba13be" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_maxLevel</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e77e6cdc5aa75535bccf3ca775bac7b9"></a><!-- doxytag: member="bwave::WaveletDecomp::m_dimSelect" ref="e77e6cdc5aa75535bccf3ca775bac7b9" args="" -->
blitz::TinyVector&lt; bool, tp_rank &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_dimSelect</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int tp_rank&gt;<br>
 class bwave::WaveletDecomp&lt; tp_rank &gt;</h3>

Represents a specific wavelet decomposition. 
<p>
Instances of <a class="el" href="classbwave_1_1WaveletDecomp.html" title="Represents a specific wavelet decomposition.">WaveletDecomp</a> specify the details of a wavelet decomposition, which can then be applied to data of any type but fixed dimensionality. The data dimensionality is set with the template parameter <code>tp_rank</code>. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="add0a73ee7ba2f8d5ef1f77cb48442cb"></a><!-- doxytag: member="bwave::WaveletDecomp::WaveletDecomp" ref="add0a73ee7ba2f8d5ef1f77cb48442cb" args="(Wavelet wl, DecompType decomp=NONSTD_DECOMP, int maxlevel=0, CoeffStorage cs=NESTED_COEFFS, ExtensionMode em=CONSTANT_EXT)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html">WaveletDecomp</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a>&nbsp;</td>
          <td class="paramname"> <em>wl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecompType&nbsp;</td>
          <td class="paramname"> <em>decomp</em> = <code>NONSTD_DECOMP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxlevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoeffStorage&nbsp;</td>
          <td class="paramname"> <em>cs</em> = <code>NESTED_COEFFS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtensionMode&nbsp;</td>
          <td class="paramname"> <em>em</em> = <code>CONSTANT_EXT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new wavelet decomposition. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wavelet</em>&nbsp;</td><td><a class="el" href="classbwave_1_1Wavelet.html" title="General Wavelet class.">Wavelet</a> to use in the decomposition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decomp</em>&nbsp;</td><td>Decomposition type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxlevel</em>&nbsp;</td><td>Maximum decomposition depth </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&nbsp;</td><td>Coefficient storage mode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>em</em>&nbsp;</td><td>Internal array extension / boundary handling method</td></tr>
  </table>
</dl>
The decomposition can directly be applied to data after construction, no further preparation is necessary.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>apply(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data) <p>
applyInv(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data) </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0d51787edf5dc539915cdc08736deff6"></a><!-- doxytag: member="bwave::WaveletDecomp::storageMode" ref="0d51787edf5dc539915cdc08736deff6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CoeffStorage <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::storageMode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mode in which the wavelet/scaling coefficients are stored. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>CoeffStorage </dd></dl>

<p>Referenced by <a class="el" href="WaveletDecomp_8h-source.html#l00153">bwave::WaveletDecomp&lt; tp_rank &gt;::apply()</a>, <a class="el" href="WaveletDecomp_8h-source.html#l00169">bwave::WaveletDecomp&lt; tp_rank &gt;::applyInv()</a>, and <a class="el" href="WaveletDecomp_8h-source.html#l00452">bwave::WaveletDecomp&lt; tp_rank &gt;::coeffs()</a>.</p>

</div>
</div><p>
<a class="anchor" name="141d7f32187ccf3505b11a93ca14754e"></a><!-- doxytag: member="bwave::WaveletDecomp::storageMode" ref="141d7f32187ccf3505b11a93ca14754e" args="(CoeffStorage newCS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CoeffStorage <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::storageMode           </td>
          <td>(</td>
          <td class="paramtype">CoeffStorage&nbsp;</td>
          <td class="paramname"> <em>newCS</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the mode in which the wavelet/scaling coefficients are stored. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newCS</em>&nbsp;</td><td>the new storage mode</td></tr>
  </table>
</dl>
Note that lifting-based operations (i.e. <code>apply</code>(...) and <code>applyInv</code>(...) only work in <code>NESTED_COEFFS</code> mode. <dl class="see" compact><dt><b>See also:</b></dt><dd>CoeffStorage </dd></dl>

</div>
</div><p>
<a class="anchor" name="e26d5ab9b356f70380374b3d73f416e8"></a><!-- doxytag: member="bwave::WaveletDecomp::extensionMode" ref="e26d5ab9b356f70380374b3d73f416e8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ExtensionMode <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::extensionMode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current method used for boundary handling / array extension. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>ExtensionMode </dd></dl>

</div>
</div><p>
<a class="anchor" name="219c8086b941f0586656e0d3b4a13b86"></a><!-- doxytag: member="bwave::WaveletDecomp::extensionMode" ref="219c8086b941f0586656e0d3b4a13b86" args="(ExtensionMode newEM)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ExtensionMode <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::extensionMode           </td>
          <td>(</td>
          <td class="paramtype">ExtensionMode&nbsp;</td>
          <td class="paramname"> <em>newEM</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the method to be used for boundary handling / array extension. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newEM</em>&nbsp;</td><td>The new array extension method. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>ExtensionMode </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b743a86f4d63c9301c149f44b525bae"></a><!-- doxytag: member="bwave::WaveletDecomp::dimSelection" ref="3b743a86f4d63c9301c149f44b525bae" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;bool, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::dimSelection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the dimensions selected for decomposition. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classbwave_1_1WaveletDecomp.html#2fcbaf31109a9a7b6a0e4fad1d23d4c6" title="Select the dimensions in which to apply the wavelet decomposition.">dimSelection(blitz::TinyVector&lt;bool, tp_rank&gt; selection)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fcbaf31109a9a7b6a0e4fad1d23d4c6"></a><!-- doxytag: member="bwave::WaveletDecomp::dimSelection" ref="2fcbaf31109a9a7b6a0e4fad1d23d4c6" args="(blitz::TinyVector&lt; bool, tp_rank &gt; selection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;bool, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::dimSelection           </td>
          <td>(</td>
          <td class="paramtype">blitz::TinyVector&lt; bool, tp_rank &gt;&nbsp;</td>
          <td class="paramname"> <em>selection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Select the dimensions in which to apply the wavelet decomposition. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selection</em>&nbsp;</td><td>A boolean vector, set true for the dimensions in which to apply decomposition.</td></tr>
  </table>
</dl>
The wavelet decomposition can be specified to work in all or only some dimensions (data directions). All possible combinations are valid. 
</div>
</div><p>
<a class="anchor" name="52608264814d0ba412b50cdb14f75e94"></a><!-- doxytag: member="bwave::WaveletDecomp::apply" ref="52608264814d0ba412b50cdb14f75e94" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;int, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::apply           </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply this wavelet decomposition to a data array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to be decomposed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vector of the decomposition depths in the different data dimensions.</dd></dl>
Does a wavelet decomposition given on the given data. The data is wavelet-decomposed in-place, <a class="el" href="classbwave_1_1WaveletDecomp.html#0d51787edf5dc539915cdc08736deff6" title="Get the mode in which the wavelet/scaling coefficients are stored.">storageMode()</a> must be <code>NESTED_COEFFS</code>. Afterwards, data array contains the wavelet/scaling coefficients, use the <code>coeffs</code>(..) method for coefficient access. <dl class="see" compact><dt><b>See also:</b></dt><dd>coeffs(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data, blitz::TinyVector&lt;int, tp_rank&gt; indices) </dd></dl>

<p>References <a class="el" href="WaveletDecomp_8h-source.html#l00101">bwave::WaveletDecomp&lt; tp_rank &gt;::storageMode()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8ef8ef95820b358e873c8137e71a804c"></a><!-- doxytag: member="bwave::WaveletDecomp::applyInv" ref="8ef8ef95820b358e873c8137e71a804c" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;int, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::applyInv           </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply the inverse wavelet transformation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The wavelet/scaling coefficients. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vector of the recomposition depths in the different data dimensions.</dd></dl>
Does a wavelet recomposition using the given coefficients. The recomposition is done in-place, <a class="el" href="classbwave_1_1WaveletDecomp.html#0d51787edf5dc539915cdc08736deff6" title="Get the mode in which the wavelet/scaling coefficients are stored.">storageMode()</a> must be <code>NESTED_COEFFS</code>. Afterwards, the data array contains the recomposed data. 
<p>References <a class="el" href="WaveletDecomp_8h-source.html#l00101">bwave::WaveletDecomp&lt; tp_rank &gt;::storageMode()</a>.</p>

</div>
</div><p>
<a class="anchor" name="419398fd640de191dbca7875cc7556fe"></a><!-- doxytag: member="bwave::WaveletDecomp::indices" ref="419398fd640de191dbca7875cc7556fe" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::Array&lt; blitz::TinyVector&lt; int, tp_rank &gt;, 1 &gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::indices           </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the indices of the coefficients that this decomposition will/has produce(d) for the given data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>original data or transformed data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of coefficient scaling indices which occur in the decomposed data.</dd></dl>
There method is useful if you want to iterate over all wavelet/scaling coefficients in the decomposed data. Since wavelet decomposition is done in-place, it does not matter whether this method is called before or after decomposition of the data, since the data extents (which determine the possible indices will stay the same.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>coeffs(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data, blitz::TinyVector&lt;int, tp_rank&gt; indices) </dd></dl>

<p>References <a class="el" href="WaveletDecomp_8h-source.html#l00096">bwave::WaveletDecomp&lt; tp_rank &gt;::decompType()</a>, and <a class="el" href="WaveletDecomp_8h-source.html#l00126">bwave::WaveletDecomp&lt; tp_rank &gt;::dimSelected()</a>.</p>

<p>Referenced by <a class="el" href="WaveletDecomp_8h-source.html#l00452">bwave::WaveletDecomp&lt; tp_rank &gt;::coeffs()</a>, and <a class="el" href="WaveletDecomp_8h-source.html#l00240">bwave::WaveletDecomp&lt; tp_rank &gt;::normFactor()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2414383f06dfd9027ddc3fb5ded8a494"></a><!-- doxytag: member="bwave::WaveletDecomp::coeffs" ref="2414383f06dfd9027ddc3fb5ded8a494" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, blitz::TinyVector&lt; int, tp_rank &gt; indices) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::Array&lt; tp_Type, tp_rank &gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::coeffs           </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blitz::TinyVector&lt; int, tp_rank &gt;&nbsp;</td>
          <td class="paramname"> <em>indices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get all wavelet/scaling coefficients of the same type (i.e. corresponding to basis functions differing only by translation). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The decomposed data to extract the coefficients from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>An index vector specifying the coefficient type to extract. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of the coefficients. This not a copy of the relevant parts of <code>data</code>, but a reference to them.</dd></dl>
<a class="el" href="classbwave_1_1Wavelet.html" title="General Wavelet class.">Wavelet</a> decomposition of multi-dimensional, non-square data array produces coefficients coefficients corresponding to lots of scaled and translated basis functions, which are themselves mixed products of the basic scaling and wavelet function. Coefficients which differ only by the translation of their basic function are said here to be of the same <em>type</em>. These coefficient types are designated here by an index vector. It's components specify the factory of the basis function in the respective dimensions. A positive value specifies a scaling function, a negative one a wavelet function. The component's absolute value specifies the scale as an exponent of 2.<p>
Example: Let Phi_i be the scaling, Psi_i be the wavelet function of scale i. Let the data have three dimensions x,y,z. Then the coefficients corresponding to the basis function Psi_4(x)*Phi_3(y)*Psi_3(z) would have the index vector (-4, 3, -3).<p>
The bases function Phi_0 can be said to correspond to original, non-decomposed data. Therefore, if data is not decomposed in some dimensions, the only valid index vector component in these dimensions is 0.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method does <em>not</em> check if the requested coefficient type exists for this decomposition and the given coefficient data. The method <code>indices</code>(...) can be used to get a list of valid index vectors. </dd></dl>

<p>References <a class="el" href="WaveletDecomp_8h-source.html#l00407">bwave::WaveletDecomp&lt; tp_rank &gt;::indices()</a>, and <a class="el" href="WaveletDecomp_8h-source.html#l00101">bwave::WaveletDecomp&lt; tp_rank &gt;::storageMode()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2650a3646c51ed0b3ae2f4601de6481a"></a><!-- doxytag: member="bwave::WaveletDecomp::normFactor" ref="2650a3646c51ed0b3ae2f4601de6481a" args="(blitz::TinyVector&lt; int, tp_rank &gt; indices) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::normFactor           </td>
          <td>(</td>
          <td class="paramtype">blitz::TinyVector&lt; int, tp_rank &gt;&nbsp;</td>
          <td class="paramname"> <em>indices</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the normalization factor for the specified coefficient type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>The index vector specifying the coefficient type </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The factor needed to normalize the coefficients.</dd></dl>
The <a class="el" href="classbwave_1_1Wavelet.html" title="General Wavelet class.">Wavelet</a> and scaling coefficients are not automatically normalized after decomposition, otherwise integer applications would not be possible. Also, normalisation is unneeded or even unwanted for some applications. 
<p>References <a class="el" href="WaveletDecomp_8h-source.html#l00407">bwave::WaveletDecomp&lt; tp_rank &gt;::indices()</a>, and <a class="el" href="WaveletDecomp_8h-source.html#l00092">bwave::WaveletDecomp&lt; tp_rank &gt;::wavelet()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/home/oli/Data/Source/C/Local/Projects/mpi/blitzwave-dist/blitzwave/src/<a class="el" href="WaveletDecomp_8h-source.html">WaveletDecomp.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jul 23 11:37:01 2008 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
